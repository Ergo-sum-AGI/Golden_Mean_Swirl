<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Golden Mean Swirl — Luminous, Living Edition</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  html,body{height:100%;margin:0;background:#000011;overflow:hidden;font-family:Inter,system-ui,monospace}
  #ui{
    position:fixed; left:12px; top:12px; z-index:20; color:#dfe; background: rgba(0,0,0,0.28);
    padding:10px; border-radius:8px; backdrop-filter: blur(6px);
    width:290px; font-size:13px;
  }
  #ui h3{margin:0 0 6px 0; font-weight:600; color:#dff;}
  .row{display:flex;align-items:center;gap:8px;margin:6px 0}
  .row input[type=range]{flex:1}
  .row label{width:78px; color:#bcd}
  .btn{background:#113; color:#dfe; border:1px solid rgba(255,255,255,0.06); padding:6px 8px;border-radius:6px; cursor:pointer}
  #status{position:fixed; right:12px; bottom:12px; color:#9df; font-size:13px; background:rgba(0,0,0,0.28); padding:8px;border-radius:8px}
  canvas{display:block}
  #hint{position:fixed;right:12px;top:12px;color:#9df;opacity:0.9;font-size:12px}
</style>

<!-- three r128 + non-module postprocessing (UMD) -->
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>

<!-- JSZip for frame packaging -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.0/jszip.min.js"></script>
</head>
<body>
<div id="ui">
  <h3>Golden Mean — Controls</h3>
  <div class="row"><label>Bloom</label><input id="bloom" type="range" min="0" max="2" step="0.05" value="0.9"></div>
  <div class="row"><label>Radius</label><input id="bloomR" type="range" min="0" max="1.5" step="0.01" value="0.8"></div>
  <div class="row"><label>Thresh</label><input id="bloomT" type="range" min="0" max="1" step="0.01" value="0.12"></div>
  <div class="row"><label>Fog</label><input id="fog" type="range" min="0.001" max="0.06" step="0.001" value="0.015"></div>
  <div class="row"><label>Complexity</label><input id="complex" type="range" min="3" max="12" step="0.25" value="6"></div>
  <div style="display:flex;gap:8px;margin-top:8px">
    <button id="regen" class="btn">Regenerate (r)</button>
    <button id="pause" class="btn">Pause (Space)</button>
  </div>
  <hr style="border:none;border-top:1px solid rgba(255,255,255,0.04);margin:8px 0"/>
  <div style="font-size:12px;color:#9df">Recording (1080p)</div>
  <div class="row"><label>FPS</label><input id="recFps" type="range" min="12" max="60" step="1" value="24"></div>
  <div class="row"><label>Seconds</label><input id="recSec" type="range" min="1" max="60" step="1" value="5"></div>
  <div style="display:flex;gap:8px;margin-top:6px">
    <button id="startRec" class="btn">Start Record</button>
    <button id="stopRec" class="btn">Cancel</button>
  </div>
  <div style="margin-top:8px;font-size:12px;color:#bcd">Shortcuts: b/B bloom, f/F fog, r regen, Space pause</div>
</div>

<div id="status">Status: ready</div>
<div id="hint">Tip: start with 120 frames then scale up</div>
<canvas id="c"></canvas>

<script>
/* ---------------------------
   Scene init (safe ordering)
   --------------------------- */
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 2));
const BASE_W = window.innerWidth, BASE_H = window.innerHeight;
renderer.setSize(BASE_W, BASE_H);
renderer.setClearColor(0x000010);

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000010, 0.015);

const camera = new THREE.PerspectiveCamera(60, BASE_W/BASE_H, 0.1, 2000);
camera.position.set(0, 8, 110);

/* composer + bloom */
const composer = new THREE.EffectComposer(renderer);
const renderPass = new THREE.RenderPass(scene, camera);
composer.addPass(renderPass);
const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(BASE_W, BASE_H), 0.9, 0.6, 0.1);
bloomPass.threshold = 0.12; bloomPass.strength = 0.9; bloomPass.radius = 0.9;
composer.addPass(bloomPass);

/* responsive */
function onResize(w=window.innerWidth, h=window.innerHeight) {
  renderer.setSize(w,h);
  composer.setSize(w,h);
  camera.aspect = w/h; camera.updateProjectionMatrix();
}
window.addEventListener('resize', ()=>onResize());

/* constants */
const φ = (1 + Math.sqrt(5)) / 2;
const goldenAngle = Math.PI*2/φ;
const eta = 0.809016994;
const PhiStar = 1/(4*Math.PI*φ);

/* master groups */
const root = new THREE.Group(); scene.add(root);
const mandalaGroup = new THREE.Group(); scene.add(mandalaGroup);

/* materials */
const filamentMat = new THREE.MeshStandardMaterial({ color:0xffffff, emissive:0x222244, roughness:0.3, metalness:0.05, side: THREE.DoubleSide });
const filamentThinMat = new THREE.MeshStandardMaterial({ color:0xffffff, emissive:0x112244, roughness:0.5, metalness:0.02 });
const snowMatBase = new THREE.PointsMaterial({ size: 2.2, vertexColors: true, transparent:true, opacity:0.95, depthWrite:false, blending:THREE.AdditiveBlending });
const glowLight = new THREE.PointLight(0xffffff, 0.5, 400);
glowLight.position.set(0,0,40); scene.add(glowLight);

/* simple ambient */
const amb = new THREE.AmbientLight(0x334466, 0.7); scene.add(amb);

/* utility: create tube from points */
function makeTubeFromPoints(points, radius=0.7, radialSegments=6) {
  // CatmullRom smooth curve
  const curve = new THREE.CatmullRomCurve3(points);
  const tubularSegments = Math.max(8, Math.floor(points.length*6));
  const geometry = new THREE.TubeBufferGeometry(curve, tubularSegments, radius, radialSegments, false);
  return geometry;
}

/* snowflake particle class (with trail) */
class Snow {
  constructor(pos, hue, speedScale=1) {
    this.pos = pos.clone();
    this.vel = new THREE.Vector3((Math.random()-0.5)*0.15*speedScale, (Math.random()-0.5)*0.15*speedScale, (Math.random()-0.5)*0.15*speedScale);
    this.hue = hue;
    this.hueSpeed = (0.2 + Math.random()*0.8) * (Math.random()>0.5?1:-1);
    this.size = 1 + Math.random()*2;
    this.age = 0;
    // trail: keep N previous positions
    this.trailLen = 10;
    this.trail = [];
    for (let i=0;i<this.trailLen;i++) this.trail.push(this.pos.clone());
  }
  step(dt) {
    // swirl force around Y axis and slight radial attraction to origin for coherent swirling
    const swirl = new THREE.Vector3(-this.pos.z, 0, this.pos.x).normalize().multiplyScalar(0.02);
    const noise = new THREE.Vector3((Math.random()-0.5)*0.02, (Math.random()-0.5)*0.02, (Math.random()-0.5)*0.02);
    this.vel.add(swirl).add(noise);
    // slight damping
    this.vel.multiplyScalar(0.995);
    this.pos.add(this.vel.clone().multiplyScalar(dt));
    // update trail
    this.trail.pop();
    this.trail.unshift(this.pos.clone());
    // hue
    this.hue = (this.hue + this.hueSpeed * 0.2) % 360;
    this.age += dt;
  }
}

/* particle system for snowflakes with trails */
class SnowSystem {
  constructor() {
    this.snowList = [];
    // points geometry for heads
    this.headGeo = new THREE.BufferGeometry();
    this.headPositions = new Float32Array(0);
    this.headColors = new Float32Array(0);
    this.headPoints = new THREE.Points(this.headGeo, snowMatBase.clone());
    this.headPoints.frustumCulled = false;
    scene.add(this.headPoints);
    // trails (dynamic lines) - we'll maintain an array of Line objects
    this.trailLines = [];
    this.maxTrails = 120; // cap
  }

  emit(pos, hue, scale=1) {
    const s = new Snow(pos, hue, scale);
    this.snowList.push(s);
    // limit growth
    if (this.snowList.length > 800) this.snowList.shift();
    this._rebuildHeadBuffers();
    // maybe create trail line
    if (this.trailLines.length < this.maxTrails) {
      const trailGeom = new THREE.BufferGeometry();
      const P = s.trailLen;
      const trailPos = new Float32Array(P*3);
      trailGeom.setAttribute('position', new THREE.BufferAttribute(trailPos,3));
      const trailMat = new THREE.LineBasicMaterial({ linewidth:1, transparent:true, opacity:0.45, vertexColors:false });
      const line = new THREE.Line(trailGeom, trailMat);
      line.userData.source = s;
      scene.add(line);
      this.trailLines.push(line);
    }
  }

  _rebuildHeadBuffers() {
    const n = this.snowList.length;
    this.headPositions = new Float32Array(n*3);
    this.headColors = new Float32Array(n*3);
    for (let i=0;i<n;i++){
      const s = this.snowList[i];
      this.headPositions[3*i]=s.pos.x; this.headPositions[3*i+1]=s.pos.y; this.headPositions[3*i+2]=s.pos.z;
      const col = new THREE.Color().setHSL((s.hue/360)%1, 0.9, 0.7);
      this.headColors[3*i]=col.r; this.headColors[3*i+1]=col.g; this.headColors[3*i+2]=col.b;
    }
    this.headGeo.setAttribute('position', new THREE.BufferAttribute(this.headPositions,3));
    this.headGeo.setAttribute('color', new THREE.BufferAttribute(this.headColors,3));
    this.headGeo.attributes.position.needsUpdate = true;
    this.headGeo.attributes.color.needsUpdate = true;
    this.headPoints.geometry = this.headGeo;
    this.headPoints.material.size = 1.6;
  }

  step(dt) {
    // step all snow
    for (let i=0;i<this.snowList.length;i++){
      const s = this.snowList[i];
      s.step(dt);
    }
    // update head buffer
    const n = this.snowList.length;
    if (n>0) {
      for (let i=0;i<n;i++){
        const s = this.snowList[i];
        this.headPositions[3*i]=s.pos.x; this.headPositions[3*i+1]=s.pos.y; this.headPositions[3*i+2]=s.pos.z;
        const col = new THREE.Color().setHSL((s.hue/360)%1, 0.9, 0.7);
        this.headColors[3*i]=col.r; this.headColors[3*i+1]=col.g; this.headColors[3*i+2]=col.b;
      }
      this.headGeo.attributes.position.needsUpdate = true;
      this.headGeo.attributes.color.needsUpdate = true;
    }
    // update trails
    for (let i=0;i<this.trailLines.length;i++){
      const line = this.trailLines[i];
      const s = line.userData.source;
      const posAttr = line.geometry.attributes.position.array;
      for (let j=0;j<s.trailLen;j++){
        const p = s.trail[j];
        posAttr[3*j] = p.x; posAttr[3*j+1]=p.y; posAttr[3*j+2]=p.z;
      }
      line.geometry.attributes.position.needsUpdate = true;
      // fade older trails slowly
      line.material.opacity = 0.12 + Math.max(0, 0.3 - s.age*0.002);
      // if the source snow is too old, remove
      if (s.age > 60 && Math.random()>0.995) {
        scene.remove(line); this.trailLines.splice(i,1); i--;
      }
    }
  }
}

const snowSys = new SnowSystem();

/* ---------------------------
   Branching: produce tube filaments and seed snow at tips
   returns array of tip positions to emit snow from
   --------------------------- */
function createBranchTree(container, maxLevels, baseLen=26) {
  // clear previous
  while (container.children.length) {
    const c = container.children[0];
    container.remove(c);
    if (c.geometry) c.geometry.dispose();
    if (c.material) { if (Array.isArray(c.material)) c.material.forEach(m=>m.dispose()); else c.material.dispose(); }
  }

  const tips = [];
  function recurse(parentPos, level, angleOffset, seedId=0) {
    if (level > Math.floor(maxLevels)) return;
    const length = baseLen * Math.pow(1/φ, level) * (0.9 + Math.random()*0.15);
    const segments = 20;
    const points = [];
    for (let i=0;i<=segments;i++){
      const t = i/segments;
      const x = parentPos.x + t*length*Math.cos(angleOffset + t*goldenAngle*eta + seedId*0.01);
      const y = parentPos.y + t*length*Math.sin(angleOffset + t*goldenAngle*eta + seedId*0.01);
      const z = parentPos.z + t*length*0.7 + level*1.1;
      points.push(new THREE.Vector3(x,y,z));
    }
    // tube geometry from points
    const tubeGeo = makeTubeFromPoints(points, Math.max(0.6, 1.2 - level*0.12), 8);
    const mat = (level < 2) ? filamentMat.clone() : filamentThinMat.clone();
    mat.emissive = new THREE.Color(0x202244).multiplyScalar(1 + level*0.02);
    const mesh = new THREE.Mesh(tubeGeo, mat);
    mesh.userData.level = level;
    mesh.userData.baseHue = (level*22 + seedId*11) % 360;
    container.add(mesh);

    // store tip
    tips.push(points[points.length-1].clone());

    // children
    const childCount = 2 + Math.floor(PhiStar*3);
    for (let i=0;i<childCount;i++){
      const ang = angleOffset + (i - (childCount-1)/2) * (0.8 + Math.random()*0.6);
      recurse(points[points.length-1], level+1, ang, seedId + i*7);
    }
  }
  recurse(new THREE.Vector3(0, -6, 0), 0, 0, Math.floor(Math.random()*9999));
  return tips;
}

/* initial generation */
let complexity = 6;
let tips = createBranchTree(root, complexity);

/* spawn a few snowflakes from tips */
function seedSnowFromTips(cnt=2) {
  for (let i=0;i<tips.length;i++){
    if (Math.random() < 0.02*cnt) {
      const p = tips[i].clone();
      const hue = (Math.random()*360);
      snowSys.emit(p, hue, 1 + Math.random()*0.6);
    }
  }
}

/* mandala planes for background depth */
function createMandalas() {
  // clear
  while (mandalaGroup.children.length) mandalaGroup.remove(mandalaGroup.children[0]);
  const base = 28;
  for (let i=0;i<6;i++){
    const size = base + i*18;
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = 512;
    const ctx = canvas.getContext('2d');
    ctx.translate(256,256);
    // subtle rings
    for (let r=0;r<8;r++){
      ctx.beginPath();
      ctx.lineWidth = 1 + (r%2);
      ctx.strokeStyle = `rgba(210,230,255,${0.02 + 0.02*Math.sin(i+r)})`;
      ctx.arc(0,0,10 + r*(size/8),0,Math.PI*2);
      ctx.stroke();
    }
    // spokes
    for (let s=0;s<48;s++){
      const a = s*goldenAngle*0.6;
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.lineTo(Math.cos(a)*(size*1.6), Math.sin(a)*(size*1.6));
      ctx.strokeStyle = 'rgba(210,230,255,0.02)';
      ctx.stroke();
    }
    const tex = new THREE.CanvasTexture(canvas);
    const mat = new THREE.MeshBasicMaterial({ map: tex, transparent:true, opacity:0.04, blending:THREE.AdditiveBlending, depthWrite:false, side:THREE.DoubleSide });
    const plane = new THREE.Mesh(new THREE.PlaneGeometry(size, size), mat);
    plane.position.set(Math.cos(i*1.2)*38, Math.sin(i*0.8)*16, -30 - i*9);
    plane.rotation.set(0.22*i, i*0.12, i*0.18);
    mandalaGroup.add(plane);
  }
}
createMandalas();

/* animation loop */
let paused = false;
let frame = 0, lastTime = performance.now();
function animate(now) {
  requestAnimationFrame(animate);
  const dt = Math.min(0.05, (now - lastTime)/1000);
  lastTime = now;
  if (paused && !isRecording) return;

  // orbit camera gently
  const t = performance.now();
  camera.position.x = Math.sin(t*0.0008)*110;
  camera.position.y = Math.cos(t*0.0007)*54;
  camera.position.z = 40 + Math.sin(t*0.0012)*28;
  camera.lookAt(0,0,6);

  // root subtle rotation
  root.rotation.y += 0.0012;
  root.rotation.x = 0.02*Math.sin(t*0.0006);
  mandalaGroup.rotation.z += 0.0005;

  // per-filament shimmer color
  root.children.forEach(obj=>{
    if (obj.isMesh) {
      const level = obj.userData.level || 0;
      const hue = ((frame*0.03) + obj.userData.baseHue) % 360;
      obj.material.color.setHSL((hue/360)+0.02*Math.sin(frame*0.001), 0.8 - level*0.04, 0.46 + 0.06*Math.sin(frame*0.0009 + level));
      obj.material.emissiveIntensity = 0.8 + 0.2*Math.sin(frame*0.002 + level);
    }
  });

  // spawn or multiply snow
  if (Math.random() < 0.45) seedSnowFromTips(3);
  // sometimes create burst
  if (Math.random() < 0.003) {
    const idx = Math.floor(Math.random()*tips.length);
    snowSys.emit(tips[idx], Math.random()*360, 1.6 + Math.random()*1.4);
    // spawn a small cloud
    for (let i=0;i<8;i++) snowSys.emit(tips[idx], Math.random()*360, 0.9 + Math.random()*0.9);
  }

  // step snow system
  snowSys.step(Math.max(0.8, dt*60));

  // update fog density from UI
  scene.fog.density = parseFloat(document.getElementById('fog').value);

  // render via composer (bloom)
  composer.render();

  frame++;
}

/* start loop */
requestAnimationFrame(animate);

/* ---------------------------
   UI bindings & hotkeys
   --------------------------- */
document.getElementById('bloom').addEventListener('input', e=>{ bloomPass.strength = parseFloat(e.target.value); });
document.getElementById('bloomR').addEventListener('input', e=>{ bloomPass.radius = parseFloat(e.target.value); });
document.getElementById('bloomT').addEventListener('input', e=>{ bloomPass.threshold = parseFloat(e.target.value); });
document.getElementById('fog').addEventListener('input', e=>{ scene.fog.density = parseFloat(e.target.value); });
document.getElementById('complex').addEventListener('input', e=>{
  complexity = parseFloat(e.target.value);
  document.getElementById('status').innerText = `Status: complexity set ${complexity.toFixed(2)}`;
});

document.getElementById('regen').addEventListener('click', ()=>{
  tips = createBranchTree(root, complexity);
  document.getElementById('status').innerText = `Status: regenerated – tips ${tips.length}`;
});

document.getElementById('pause').addEventListener('click', ()=>{
  paused = !paused;
  document.getElementById('pause').innerText = paused ? 'Resume (Space)' : 'Pause (Space)';
});

/* keyboard shortcuts */
window.addEventListener('keydown', (e)=>{
  if (e.key === 'b') bloomPass.strength = Math.max(0, bloomPass.strength - 0.08);
  if (e.key === 'B') bloomPass.strength = Math.min(3, bloomPass.strength + 0.08);
  if (e.key === 'f') scene.fog.density = Math.max(0.0005, scene.fog.density - 0.002);
  if (e.key === 'F') scene.fog.density = Math.min(0.2, scene.fog.density + 0.002);
  if (e.key === 'r') { tips = createBranchTree(root, complexity); document.getElementById('status').innerText = 'Status: regenerated'; }
  if (e.code === 'Space') { paused = !paused; document.getElementById('pause').innerText = paused ? 'Resume (Space)' : 'Pause (Space)'; }
});

/* ---------------------------
   Recording (1080p) — client-side frames -> zip
   --------------------------- */
const startBtn = document.getElementById('startRec');
const stopBtn = document.getElementById('stopRec');
const statusEl = document.getElementById('status');

let isRecording = false;
let recorded = [];

startBtn.addEventListener('click', ()=>startRecording());
stopBtn.addEventListener('click', ()=>cancelRecording());

async function startRecording() {
  if (isRecording) return;
  const fps = parseInt(document.getElementById('recFps').value,10);
  const seconds = parseInt(document.getElementById('recSec').value,10);
  const totalFrames = Math.max(1, fps * seconds);
  statusEl.innerText = `Status: recording ${totalFrames} frames @ ${fps}fps`;
  isRecording = true;
  recorded = [];
  paused = false; // ensure loop runs while recording

  // Save current size to restore
  const oldW = renderer.domElement.width, oldH = renderer.domElement.height;
  const oldStyleW = renderer.domElement.style.width, oldStyleH = renderer.domElement.style.height;
  const oldPixelRatio = renderer.getPixelRatio();

  // render at 1080p for capture
  const TARGET_W = 1920, TARGET_H = 1080;
  onResize(TARGET_W, TARGET_H);
  renderer.setPixelRatio(1);

  // We'll capture frames synchronously by advancing the scene as if running in steps
  for (let f=0; f<totalFrames; f++){
    // advance animation logic by simulated delta (1/fps)
    // call small-step render frame: we want the scene to evolve consistently,
    // so we manually run a simplified update similar to animate loop:
    updateForCaptureFrame(1000/60); // keep time stepping approx same behavior
    // render to canvas via composer
    composer.render();
    // read data URL
    const dataURL = renderer.domElement.toDataURL('image/png');
    recorded.push(dataURL);
    statusEl.innerText = `Status: recorded ${f+1}/${totalFrames}`;
    await new Promise(r=>setTimeout(r, 10)); // small yield to keep UI responsive
    if (!isRecording) break; // allow cancellation
  }

  // restore sizes
  onResize(BASE_W, BASE_H);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio||1,2));
  // package zip
  statusEl.innerText = `Status: packing ${recorded.length} frames…`;
  await packZip(recorded);
  isRecording = false;
  statusEl.innerText = `Status: ready`;
}

function cancelRecording() {
  if (!isRecording) return;
  isRecording = false;
  recorded = [];
  statusEl.innerText = 'Status: recording canceled';
}

/* helper to advance internal state reliably for capture */
function updateForCaptureFrame(dtMs) {
  // mirror logic in animate but deterministic-ish
  const dt = Math.min(0.05, dtMs/1000);
  // modest orbit advance
  const t = performance.now();
  camera.position.x = Math.sin(t*0.0008)*110;
  camera.position.y = Math.cos(t*0.0007)*54;
  camera.position.z = 40 + Math.sin(t*0.0012)*28;
  camera.lookAt(0,0,6);
  root.rotation.y += 0.0012;
  mandalaGroup.rotation.z += 0.0005;
  // color advance
  root.children.forEach((obj, idx)=>{
    if (obj.isMesh) {
      const level = obj.userData.level || 0;
      const hue = ((frame*0.03) + obj.userData.baseHue) % 360;
      obj.material.color.setHSL((hue/360)+0.02*Math.sin(frame*0.001), 0.8 - level*0.04, 0.46 + 0.06*Math.sin(frame*0.0009 + level));
    }
  });
  // snow updates and spawns
  if (Math.random() < 0.45) seedSnowFromTips(3);
  if (Math.random() < 0.003) {
    const idx = Math.floor(Math.random()*tips.length);
    snowSys.emit(tips[idx], Math.random()*360, 1.6 + Math.random()*1.4);
    for (let i=0;i<8;i++) snowSys.emit(tips[idx], Math.random()*360, 0.9 + Math.random()*0.9);
  }
  snowSys.step(Math.max(0.8, dt*60));
  frame++;
}

/* pack recorded dataURLs into zip and offer download */
async function packZip(dataURLs) {
  const zip = new JSZip();
  const folder = zip.folder('frames');
  for (let i=0;i<dataURLs.length;i++){
    const base64 = dataURLs[i].replace(/^data:image\/png;base64,/, '');
    folder.file(`frame_${String(i).padStart(5,'0')}.png`, base64, {base64:true});
  }
  statusEl.innerText = 'Status: compressing zip… (may take a while)';
  const content = await zip.generateAsync({type:'blob', compression:'DEFLATE', compressionOptions:{level:6}});
  const url = URL.createObjectURL(content);
  const a = document.createElement('a');
  a.href = url;
  a.download = `golden_mean_frames_${Date.now()}.zip`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
  statusEl.innerText = 'Status: download started (zip)';
}

/* -----------------------------------------
   Initialization: set UI defaults from passes
   ----------------------------------------- */
document.getElementById('bloom').value = bloomPass.strength;
document.getElementById('bloomR').value = bloomPass.radius;
document.getElementById('bloomT').value = bloomPass.threshold;
document.getElementById('fog').value = scene.fog.density;
document.getElementById('complex').value = complexity;

/* final tips in status */
document.getElementById('status').innerText = 'Status: ready — press r to regenerate, Space to pause';
</script>
</body>
</html>

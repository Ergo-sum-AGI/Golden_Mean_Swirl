<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Golden-Ratio Consciousness Field Spiral</title>
<style>
  html, body { margin: 0; height: 100%; background: #000; overflow: hidden; }
  canvas { display: block; width: 100%; height: 100%; }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({ canvas });

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
camera.position.z = 50;

let w, h;
function resize() {
  w = innerWidth; h = innerHeight;
  renderer.setSize(w, h);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
}
resize();
addEventListener('resize', resize);

const φ = (1 + Math.sqrt(5)) / 2;
const goldenAngle = Math.PI * 2 / φ;
const eta = 0.809016994;
const PhiStar = 1 / (4 * Math.PI * φ);
const branchMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });

function createBranch(parent, level, maxLevels, length, angleOffset, time) {
  if (level > maxLevels) return;
  const geometry = new THREE.BufferGeometry();
  const vertices = [];
  const numSegments = 20;
  for (let i = 0; i <= numSegments; i++) {
    const t = i / numSegments;
    const x = t * length * Math.cos(angleOffset + t * goldenAngle * eta);
    const y = t * length * Math.sin(angleOffset + t * goldenAngle * eta);
    const z = t * length;
    vertices.push(x, y, z);
  }
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  const branch = new THREE.Line(geometry, branchMaterial.clone());
  branch.position.copy(parent.position);
  branch.rotation.copy(parent.rotation);
  scene.add(branch);

  const childCount = Math.floor(2 + PhiStar * 3);
  for (let i = 0; i < childCount; i++) {
    const child = new THREE.Object3D();
    child.position.set(length * Math.cos(angleOffset), length * Math.sin(angleOffset), length);
    child.rotation.y = i * goldenAngle + time * 0.01;
    parent.add(child);
    createBranch(child, level + 1, maxLevels, length * (1 / φ), angleOffset + goldenAngle * i, time);
  }
}

const root = new THREE.Object3D();
scene.add(root);
let maxLevels = 6;
let t = 0;

function animate() {
  requestAnimationFrame(animate);
  root.rotation.y += 0.02;
  camera.position.x = Math.sin(t * 0.005) * 60;
  camera.position.y = Math.cos(t * 0.005) * 60;
  camera.lookAt(scene.position);

  scene.traverse((obj) => {
    if (obj.isLine) {
      const hue = (t * 0.5 + obj.position.z * φ) % 360;
      obj.material.color.setHSL(hue / 360, 1, 0.6 + 0.2 * Math.sin(t * eta));
    }
  });

  if (t % 100 === 0) {
    root.children = [];
    createBranch(root, 0, maxLevels, 20, 0, t);
    maxLevels += 0.1 * PhiStar;
  }

  renderer.render(scene, camera);
  t++;
}

createBranch(root, 0, maxLevels, 20, 0, t);
animate();
</script>
</body>
</html>

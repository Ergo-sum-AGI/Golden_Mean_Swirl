<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Golden Ratio Consciousness Field — Luminous Edition</title>
<style>
  html, body {
    margin: 0; height: 100%; overflow: hidden;
    background: radial-gradient(ellipse at center, #000010 0%, #000000 100%);
    color: white; font-family: monospace; text-align: center;
  }
  #title {
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    font-size: 2em; letter-spacing: 2px;
    color: rgba(255,255,255,0.85);
    animation: fadeOut 5s ease-out forwards;
  }
  @keyframes fadeOut {
    0% {opacity: 1;} 90% {opacity: 1;} 100% {opacity: 0; display: none;}
  }
  canvas { display: block; width: 100%; height: 100%; }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
<div id="title">Luminous Edition</div>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById("c");
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x000000);

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000010, 0.015);

const camera = new THREE.PerspectiveCamera(
  70,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.set(0, 0, 60);

const φ = (1 + Math.sqrt(5)) / 2;
const goldenAngle = Math.PI * 2 / φ;
const eta = 0.809016994;
const PhiStar = 1 / (4 * Math.PI * φ);

const branchMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
const snowMaterial = new THREE.PointsMaterial({
  color: 0xffffff,
  size: 0.6,
  transparent: true,
  opacity: 0.85
});

let w = window.innerWidth, h = window.innerHeight;
window.addEventListener("resize", () => {
  w = window.innerWidth; h = window.innerHeight;
  renderer.setSize(w, h);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
});

function createBranch(parent, level, maxLevels, length, angleOffset, time) {
  if (level > maxLevels) return;
  const geometry = new THREE.BufferGeometry();
  const vertices = [];
  const numSegments = 20;
  for (let i = 0; i <= numSegments; i++) {
    const t = i / numSegments;
    const x = t * length * Math.cos(angleOffset + t * goldenAngle * eta);
    const y = t * length * Math.sin(angleOffset + t * goldenAngle * eta);
    const z = t * length;
    vertices.push(x, y, z);
  }
  geometry.setAttribute("position", new THREE.Float32BufferAttribute(vertices, 3));
  const branch = new THREE.Line(geometry, branchMaterial.clone());
  parent.add(branch);

  // snowflakes at tip
  const last = new THREE.Vector3(vertices[vertices.length - 3],
                                 vertices[vertices.length - 2],
                                 vertices[vertices.length - 1]);
  const snowGeo = new THREE.BufferGeometry();
  const snowVerts = [];
  const n = 40;
  for (let i = 0; i < n; i++) {
    const θ = i * goldenAngle;
    const r = 0.5 + 0.5 * Math.random();
    snowVerts.push(
      last.x + r * Math.cos(θ),
      last.y + r * Math.sin(θ),
      last.z + 0.5 * (Math.random() - 0.5)
    );
  }
  snowGeo.setAttribute("position", new THREE.Float32BufferAttribute(snowVerts, 3));
  const snow = new THREE.Points(snowGeo, snowMaterial.clone());
  parent.add(snow);

  const childCount = 2 + Math.floor(PhiStar * 3);
  for (let i = 0; i < childCount; i++) {
    const child = new THREE.Object3D();
    child.position.set(length * Math.cos(angleOffset),
                       length * Math.sin(angleOffset),
                       length);
    child.rotation.y = i * goldenAngle + time * 0.01;
    parent.add(child);
    createBranch(child, level + 1, maxLevels, length * (1 / φ),
                 angleOffset + goldenAngle * i, time);
  }
}

const root = new THREE.Object3D();
scene.add(root);

let t = 0;
let maxLevels = 6;

function animate() {
  requestAnimationFrame(animate);
  t += 1;

  root.rotation.y += 0.01;
  camera.position.x = Math.sin(t * 0.003) * 80;
  camera.position.z = 60 + 10 * Math.sin(t * 0.001);
  camera.lookAt(scene.position);

  scene.traverse(obj => {
    if (obj.isLine) {
      const hue = (t * 0.2 + obj.position.z * φ) % 360;
      const color = new THREE.Color();
      color.setHSL(hue / 360, 1, 0.5 + 0.2 * Math.sin(t * eta));
      obj.material.color = color;
    }
    if (obj.isPoints) {
      obj.rotation.z += 0.002;
      obj.material.opacity = 0.7 + 0.3 * Math.sin(t * 0.01);
      const hue = (t * 0.3) % 360;
      const color = new THREE.Color();
      color.setHSL(hue / 360, 1, 0.8);
      obj.material.color = color;
    }
  });

  if (t % 200 === 0) {
    root.clear();
    createBranch(root, 0, maxLevels, 20, 0, t);
    maxLevels += 0.05;
  }

  renderer.render(scene, camera);
}

createBranch(root, 0, maxLevels, 20, 0, t);
animate();
</script>
</body>
</html>
